---
title: "Computation of of the model in  Morten (2019)"
author: "Mizuhiro Suzuki"
date: "11/13/2020"
bibliography: risksharing.bib
output:
  html_document:
    toc: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
packages <- c(
  "tidyverse",
  "knitr",
  "nleqslv",
  "ggrepel",
  "rootSolve",
  "BB",
  "pracma",
  "latex2exp"
)

pacman::p_load(packages, character.only = TRUE)
```

# Model

Consider a model with two households with identical preferences.
The model considers two sub-periods in one period: before-migration and after-migration.
Correspondingly, there are two value functions and two sets of promise-keeping constraints.
The before-migration constraint applies at the time when migration decisions are made: the expected value of the following the social planner's migration rule needs to be at least as great as the expected value of making an independent migration decision and then staying in autarky.
The second constraint, the after-migration constraint, applied after migration decisions have been made and all migration outcomes have been realized: the value of following the social planner's risk-sharing transfer rule needs to be at least as great as the value of consuming the current income and then remaining in autarky.

## Values of outside options

Notice that the outside options at the two points in time are different due to random realization in migration income.
The before-migration outside value, $\Omega^i$, is the value of making a decision whether or not to migration today and then facing the same choice the following period:

$$
  \Omega^i(s; z) = \max \{ u(y^i(s; z)), E_q [u(\tilde{y}^i(s, q, j; z)) - d(z)] \} + \beta \sum_r \pi^s(r|s) \Omega^i(r; z).
$$
Here, 

- $s$: realization of village income, $q$: realization of migration income, $j$: migration decision
- $z$: characteristics of the two households
- $y^i(s;z)$: village income
- $\tilde{y}^i(s, q, j;z)$: after-migration income (village income + migration income)
- $d(z)$: utility cost of migration
- $\pi^s(r|s)$: the transition probability of village income realization from state $s$ to state $r$.

That is, the autarky value is the value without risk-sharing, in which households choose whether to migrate or not.
Notice that, once in autarky before migration, the outside value after migration does not matter since in anyway transfers do not happen.

The after-migration outside value, $\tilde{\Omega}^i$ is the value of consuming period $t$ income (i.e. without transfers), conditional on the migration choice, the state in the village, and the state at the destination, and then teturning to the village and getting the before-migration level of autarky the following period:

$$
  \tilde{\Omega}^i(s, q, j; z) = u(\tilde{y}^i(s, q, j;z)) - \mathcal{I}^i(j) d(z) + \beta \sum_r \pi^s(r|s) \Omega_i(r; z).
$$

Here, $\mathcal{I}^i(j) = 1$ if $j$ indicates that $i$ migrates and $\mathcal{I}^i(j) = 0$ otherwise.

<!--

## Lagrangian formulation

The social planner chooses consumption ($c_{it}$) and migration decision ($j_t$) of each household in each period to meximize the weighted sum of households' expected lifetime utilities:

$$
  E_1 \left[ \sum_i \lambda_i \sum_{t = 1}^{\infty} \beta^t \left( u(c_{it}) - \mathcal{I}^i(j_t) d(z) \right) \right],
$$
where $\lambda_i$ is the initial Pareto weight of $i$.
The constraints for this maximization problem are the followings:

1. Optimal migration decision to maximize the total lifetime utility:

$$
  j_{t} = \arg \max_{j} E \left[ \sum_{r = t + 1}^{\infty} \beta^{r - (t + 1)} \left\{ u(c_{ir}) - \mathcal{I}^i(j_r) d(z) \right\} | s_{t + 1}, j, h^t \right] \quad \forall h^t, \forall s_{t + 1}, \forall t
$$


2. After-migration constraints:

$$
  E_t \left[ \sum_{r = t}^{\infty} \beta^{r - t} \left\{ u(c_{ir}) - \mathcal{I}^i(j_r) d(z) \right\} \right] \ge \tilde{\Omega}^i (s_t, q_t, j_t; z) \quad \forall h^t, \forall t
$$

3. Before-migration constraints (for the following period):

$$
  E \left[ \sum_{r = t + 1}^{\infty} \beta^{r - (t + 1)} \left\{ u(c_{ir}) - \mathcal{I}^i(j_r) d(z) \right\} | s_{t + 1}, j_{t + 1}, h^t \right] \ge \Omega^i (s_{t + 1}; z) \quad \forall h^t, \forall s_{t + 1}, \forall t
$$

4. Aggregate resource constraints:

$$
  \sum_i c_{it}(h^t) \le \sum_i \left( \tilde{y}^i(s_t, q_t, j_t; z) - \mathcal{I}^i(j_t) \tilde{d}(z) \right) \quad \forall h^t, \forall t,
$$
where $\tilde{d}(z)$ is the physical cost of migration, which is a part of $d(z)$.

For this maximization problem, I consider the two step procedure.
In the first step, I derive 

Denoting the Lagrangian multipliers of these constraints by $\delta^t \pi(h^t) \mu_i(h^t)$, $\delta^t \pi(h^t) \xi_i(s_{t + 1}, h^t)$, and $\delta^t \pi(h^t) \rho(h^t)$, the Lagrangian is

$$
  \sum_{t = 1}^{\infty} \sum_{h^t} \delta^t \pi(h^t) \left\{ \sum_i \left[ \lambda_i u(c_{it}(h^t)) + \\
  \mu_i(h^t) \left( \sum_{r = t}^{\infty} \sum_{s^r} \delta^{r - t} \pi(h^r|h^t) \left\{ u(c_{ir} h^r) - \mathcal{I}^i(j_r) d(z) \right\} - \tilde{\Omega}^i(s_t, q_t, j_t; z) \right) + \\
  \sum_{s_{t + 1}} \xi_i(s_{t + 1}, h^t) \left( \max_{j_{t + 1}} E \left[  \sum_{r = t}^{\infty} \sum_{s^r} \delta^{r - t} \pi(h^r|h^t) \left\{ u(c_{ir} h^r) - \mathcal{I}^i(j_r) d(z) \right\} - \tilde{\Omega}^i(s_t, q_t, j_t; z) | s_{t + 1}, j_{t + 1}, h^t \right]  - \Omega^i(s_{t + 1}; z) \right) \right] + \\
  \rho(h^t) \sum_i \left( \tilde{y}^i(s_t, q_t, j_t; z) - \left( c_{it}(h^t) + \mathcal{I}^i(j_t) \tilde{d}(z) \right) \right) \right\}.
$$

-->

## Optimization problem

Before migration, migration decision of two households is made to maximize total utility:

$$
  V_s(U_s(h^{t - 1}; z); z) = \max_j \tilde{V}_{sj}(U_s(h^{t - 1}; z); z).
$$

Here, $V_s(U_s(h^{t - 1}; z); z)$ is the value function of HH2 before migration, given the promised utility of HH1, $U_s(h^{t - 1}; z)$, and $\tilde{V}_{sj}(U_s(h^{t - 1}; z); z)$ is the value function of HH2 after migration, conditional on the migration decision $j$ is made.
Also, $h^t$ is the history term, where $h^t = \left\{ s_t, q_t, j_t, h^{t - 1} \right\}$.
The after-migration value function is defined as follows:

$$
  \tilde{V}_{sj}(U_s(h^{t - 1}; z); z) = \max_{\tau(s, q, j, h^{t - 1}; z), \{U_r(h^t; z) \}} E_q \left[ u( \tilde{y}^2(s, q, j; z) + \tau(s, q, j, h^{t - 1}; z)) - \mathcal{I}^2(j) d(z) + \beta \sum_r \pi^s(r|s) V_r(U_r(h^t; z); z) \right],
$$
where $h^t$ is the history of state variables up to $t$ ($h^t = \{s_t, q_t, j_t, h^{t - 1} \}$), subject to the following conditions:

1. Promising keeping in expectation:
$$
  E_q \left[ u(\tilde{y}^1(s, q, j; z) - \tau(s, q, j, h^{t - 1}; z)) - \mathcal{I}^1(j) d(z) + \beta \sum_r \pi^s(r|s) U_r(h^t; z) \right] = U_s(h^{t - 1}; z) \quad \forall j
$$
2. After migration constraints:

$$
  u(\tilde{y}^1(s, q, j; z) - \tau(s, q, j, h^{t - 1}; z)) - \mathcal{I}^1(j) d(z) + \beta \sum_r \pi^s(r|s) U_r(h^t; z) \ge \tilde{\Omega}^1 (s, q, j; z) \quad \forall s, q, j
$$
$$
  u(\tilde{y}^2(s, q, j; z) + \tau(s, q, j, h^{t - 1}; z)) - \mathcal{I}^2(j) d(z) + \beta \sum_r \pi^s(r|s) V_r(U_r(h^t; z); z) \ge \tilde{\Omega}^2 (s, q, j; z) \quad \forall s, q, j
$$
3. Before-migration constraints (for the following period):

$$
  U_r(h^t; z) \ge \Omega^1(r; z) \quad \forall r, s, q, j
$$
$$
  V_r(U_r(h^t; z); z)  \ge \Omega^2(r; z) \quad \forall r, s, q, j
$$

Based on these, construct a Lagrangian:

$$
  \tilde{V}_{sj}(U_s(h^{t - 1}; z); z) = E_q \left[ u(\tilde{y}^2(s, q, j; z) + \tau(s, q, j, h^{t - 1}; z)) - \mathcal{I}^2(j) d(z) + \beta \sum_r \pi^s(r|s) V_r(U_r(h^t; z); z) \right] \\
  + \lambda_j(s_t, h^{t - 1}) \left(E_q \left[ u(\tilde{y}^1(s, q, j; z) - \tau(s, q, j, h^{t - 1}; z)) - \mathcal{I}^1(j) d(z) + \beta \sum_r \pi^s(r|s) U_r(h^t; z) \right] - U_s(h^{t - 1}; z) \right) \\
  + \pi^q(q) \alpha^1(s, q, j) \left( u(\tilde{y}^1(s, q, j; z) - \tau(s, q, j, h^{t - 1}; z)) - \mathcal{I}^1(j) d(z) + \beta \sum_r \pi^s(r|s) U_r(h^t; z) - \tilde{\Omega}^1 (s, q, j; z) \right) \\
  + \pi^q(q) \alpha^2(s, q, j) \left( u(\tilde{y}^2(s, q, j; z) + \tau(s, q, j, h^{t - 1}; z)) - \mathcal{I}^2(j) d(z) + \beta \sum_r \pi^s(r|s) V_r(U_r(h^t; z); z) - \tilde{\Omega}^2 (s, q, j; z) \right) \\
  + \beta \pi^s(r|s) \pi^q(q) \phi^1(r, s, q, j) \left( U_r(h^t; z) - \Omega^1(r; z) \right) \\
  + \beta \pi^s(r|s) \pi^q(q) \phi^2(r, s, q, j) \left( V_r(U_r(h^t; z); z) - \Omega^2(r; z) \right)
$$

The first order conditions are 

$$
  \pi^q(q) \left[ u'(c^2(s, q, j, h^{t - 1}; z)) \right] - \lambda_j(s_t, h^{t - 1}) \pi^q(q) \left[ u'(c^1(s, q, j, h^{t - 1}; z)) \right] \\
  - \pi^q(q) \alpha^1(s, q, j) u^1(c^1(s, q, j, h^{t - 1}; z)) \\
  + \pi^q(q) \alpha^2(s, q, j) u^1(c^2(s, q, j, h^{t - 1}; z)) = 0 \\
  \Rightarrow \frac{u'(c^2(s, q, j, h^{t - 1}; z))}{u'(c^1(s, q, j, h^{t - 1}; z))} = \frac{\lambda_j(s_t, h^{t - 1}) + \alpha^1(s, q, j)}{1 + \alpha^2(s, q, j)} \quad \forall q
$$

and 

$$
  \pi^q(q) \beta \pi^s(r|s) V'_r(U_r(h^t; z); z) + \lambda_j(s_t, h^{t - 1}) \pi^q(q) \beta \pi^s(r|s) \\
  + \pi^q(q) \alpha^1(s, q, j) \beta \pi^s(r|s) + \pi^q(q) \alpha^2(s, q, j) \beta \pi^s(r|s) V'_r(U_r(h^t; z); z) \\
  + \pi^q(q) \phi^1(r, s, q, j) \beta \pi^s(r|s) + \pi^q(q) \phi^2(r, s, q, j) \beta \pi^s(r|s) V'_r(U_r(h^t; z); z) = 0 \\
  \Rightarrow V'_r(U_r(h^t; z); z) = - \frac{\lambda_j(s_t, h^{t - 1}) + \alpha_1(s, q, j) + \phi^1(r, s, q, j)}{1 + \alpha_2(s, q, j) + \phi^2(r, s, q, j)}.
$$

The envelope condition is

$$
  \tilde{V}'_{sj} (U_s(h^{t - 1}; z); z) = - \lambda_j(s_t, h^{t - 1}).
$$

Also, under the optimal migration decision, $V_s(U_s(h^{t - 1}; z); z) = \tilde{V}_{sj}(U_s(h^{t - 1}; z); z)$.
Using these, we obtain $V'_r(U_r(h^t; z); z) = \frac{V'_s(U_s(h^{t - 1}; z); z) - \alpha^1(s, q, j) - \phi^1(r, s, q, j)}{1 + \alpha^2(s, q, j) + \phi^2(r, s, q, j)} \quad \forall r, s, q$.
Let $\lambda(s_t, h^{t - 1})$ be $\lambda_j(s_t, h^{t - 1})$ under the optimal migration decision given $(s_t, h^{t - 1})$.
Then, letting $\tilde{\lambda}(h^t) = \frac{\lambda(s_t, h^{t - 1}) + \alpha^1(s_t, q_t, j_t)}{1 + \alpha^1(s_t, q_t, j_t)}$, Morten finds that

$$
  \tilde{\lambda(h^t)} = \begin{cases}
  \underline{\tilde{\lambda}}_{sqj} & \text{if } \lambda(s_t, h^{t - 1}) \le \underline{\tilde{\lambda}}_{sqj} \\
  \lambda(s_t, h^{t - 1}) & \text{if } \lambda(s_t, h^{t - 1}) \in \left[ \underline{\tilde{\lambda}}_{sqj}, \overline{\tilde{\lambda}}_{sqj}  \right] \\
  \overline{\tilde{\lambda}}_{sqj} & \text{if } \lambda(s_t, h^{t - 1}) \ge \overline{\tilde{\lambda}}_{sqj} 
  \end{cases}
$$

and

$$
  \lambda(r_{t + 1}, h^t) = \begin{cases}
  \underline{\lambda_{r}} & \text{if } \tilde{\lambda}(h^t) \le \underline{\lambda_{r}} \\
  \tilde{\lambda}(h^t) & \text{if } \tilde{\lambda}(h^t) \in \left[ \underline{\lambda_{r}}, \overline{\lambda_{r}}  \right] \\
  \overline{\lambda_{r}} & \text{if } \tilde{\lambda}(h^t) \ge \overline{\lambda_{r}} 
  \end{cases}.
$$

Importantly, these intervals do not depend on the past history.

# Model simulation

## Model settings

### Village income

```{r}
# village income shocks and their transition probabilities of HH1
vil_inc1 <- c(2/3, 4/3)
vil_P1 <- matrix(rep(c(0.1, 0.9), 2), nrow = 2, byrow = TRUE)

# village income shocks and their transition probabilities of HH2
vil_inc2 <- c(2/3, 4/3)
vil_P2 <- matrix(rep(c(0.1, 0.9), 2), nrow = 2, byrow = TRUE)

# transition super-matrix of village income shocks
vil_R <- kronecker(vil_P2, vil_P1)

# number of states
# (number of village income states for HH1 times
# number of village income states for HH2)
vil_S <- length(vil_inc1) * length(vil_inc2)

# village income matrix
# (col 1: HH1 village income, col 2: HH2 village income)
vil_inc_mat <- as.matrix(expand.grid(vil_inc1, vil_inc2))

# aggregate village income in each state
vil_inc_ag <- rowSums(vil_inc_mat)

```

### Migration income

```{r}
# migration income shocks and their probabilities of HH1
mig_inc1 <- c(2/3, 4/3)
mig_P1 <- c(0.1, 0.9)

# migration income shocks and their probabilities of HH2
mig_inc2 <- c(4/3, 5/3)
mig_P2 <- c(0.1, 0.9)

# transition super-matrix of migration income shocks
mig_R <- kronecker(mig_P2, mig_P1)

# number of states
# (number of migration income states for HH1 times
# number of migration income states for HH2)
mig_S <- length(mig_inc1) * length(mig_inc2)

# migration income matrix
# (col 1: HH1 migration income, col 2: HH2 migration income)
mig_inc_mat <- as.matrix(expand.grid(mig_inc1, mig_inc2))

# aggregate migration income in each state
mig_inc_ag <- rowSums(mig_inc_mat)

# migration decision matrix
mig_dec_mat <- as.matrix(expand.grid(c(0, 1), c(0, 1)))

```

### Total income (village income + migration income)

```{r}
# total income (village income + migration income), depending on s, q, and j
total_mig_inc1 <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat)))
total_mig_inc2 <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat)))
total_mig_inc <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat)))
for (j in 1:nrow(mig_dec_mat)) {
    total_mig_inc1[,,j] <- mig_dec_mat[j, 1] * (
      matrix(vil_inc_mat[,1], nrow = vil_S, ncol = mig_S) +
          matrix(mig_inc_mat[,1], nrow = vil_S, ncol = mig_S, byrow = TRUE)
    ) +
    (1 - mig_dec_mat[j, 1]) * matrix(vil_inc_mat[,1], nrow = vil_S, ncol = mig_S)
    
    total_mig_inc2[,,j] <- mig_dec_mat[j, 2] * (
      matrix(vil_inc_mat[,2], nrow = vil_S, ncol = mig_S) +
          matrix(mig_inc_mat[,2], nrow = vil_S, ncol = mig_S, byrow = TRUE)
    ) +
    (1 - mig_dec_mat[j, 2]) * matrix(vil_inc_mat[,2], nrow = vil_S, ncol = mig_S)
    
    total_mig_inc[,,j] <- total_mig_inc1[,,j] + total_mig_inc2[,,j] 
}

```

The utility function takes the CRRA form:

$$
  u(c_{it}) = \frac{c_{it}^{1 - \sigma} - 1}{1 - \sigma}.
$$

```{r}
# Define utility function
util <- function(c, sigma) {
  if (sigma != 1) {
    output = (c ^ (1 - sigma) - 1) / (1 - sigma)
  } else if (sigma == 1) {
    output = log(c)
  }
  return(output)
}

util_prime <- function(c, sigma) c ^ (- sigma)

```

The paramters are set as follows:

```{r}
beta <- 0.95 # time discount factor 
sig <- 1.5 # coefficient of relative risk aversion of HH1 and HH2
d <- 0.8 # migration cost
```

Here, what is slightly different from the original model in Morten (2019) is that the after-migration income $(\tilde{y}^i(s_t, q_t, j_t; z))$ is the simple sum of migration income and village income, rather than the weighted average of them.
So, in my model here, after earning income in village, some households send members to the urban to earn money, and the households that do not send migrants earn nothing while the slack season.

## Grid of relative Pareto weights and consumption on the grid points

Here, I make the grid of relative Pareto weight at the beginning of each period, $\lambda$, on which I compute HH1 consumption.
The number of grid points is 400.

```{r}
# (Number of grid points on relative Pareto weight) - 1
g <- 399

# The grid points of relative Pareto weights with migration
lambda_min <- util_prime(max(total_mig_inc2), sig) / util_prime(min(total_mig_inc1), sig)
lambda_max <- util_prime(min(total_mig_inc2), sig) / util_prime(max(total_mig_inc1), sig)
lambda <- exp(seq(log(lambda_min), log(lambda_max), length.out = (g + 1)))
```

Then, I compute consumptions of the household 1 on these grid points.
From the optimality condition and the CRRA utility functions, we obtain

$$
  c^1(s, q, j, \lambda; z) = \frac{\tilde{y}^1(s, q, j; z) + \tilde{y}^2(s, q, j; z)}{1 + \lambda^{- 1 / \sigma}}.
$$

```{r}
# The grid points of consumption without migration:
# Consumption is determined by aggregate income (vil_inc_ag) and
# relative Pareto weights (lambda)
cons1 <- matrix(nrow = vil_S, ncol = (g + 1))
cons2 <- matrix(nrow = vil_S, ncol = (g + 1))
for (k in 1:vil_S) {
  for (l in 1:(g + 1)) {
    cons1[k, l] <- vil_inc_ag[k] / (1 + lambda[l]^(- 1 / sig))
    cons2[k, l] <- vil_inc_ag[k] - cons1[k, l]
  }
}

# The grid points of consumption with migration:
# Consumption is determined by total income (total_mig_inc) and
# relative Pareto weights (lambda)
mig_cons1 <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat), g + 1))
mig_cons2 <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat), g + 1))
for (j in 1:nrow(mig_dec_mat)) {
    for (l in 1:(g + 1)) {
      mig_cons1[,,j,l] <- total_mig_inc[,,j] / (1 + lambda[l]^(- 1 / sig))
      mig_cons2[,,j,l] <- total_mig_inc[,,j] - mig_cons1[,,j,l]
    }
}


```

## First-best risk sharing without migration

To obtain the value functions under first-best risk sharing without migration, given Pareto weights, I use the following recursive equation:

$$
  V^i_{fb}(s, \lambda) = u \left( c_{it}(s, \lambda) \right) + \beta E[V^i_{fb}(s', \lambda)].
$$

```{r}
V_full_func <- function(
  vil_inc1, vil_P1, vil_inc2, vil_P2, g,
  vil_R, vil_S, vil_inc_ag, lambda_min, lambda_max, lambda,
  beta, sig,
  util, util_prime, cons1, cons2
  ) {

  # Value function iterations ================
  # Initial guess is the utility under equal allocation
  V1 <- util(cons1, sig)
  V2 <- util(cons2, sig)
  V1_new <- matrix(nrow = vil_S, ncol = (g + 1))
  V2_new <- matrix(nrow = vil_S, ncol = (g + 1))

  # Obtain value functions by value function iterations
  j <- 1
  diff <- 1
  while (diff > 1e-8 & j < 500) {
    V1_new <- util(cons1, sig) + beta * vil_R %*% V1
    V2_new <- util(cons2, sig) + beta * vil_R %*% V2
    diff <- max(max(abs(V1_new - V1)), max(abs(V2_new - V2)))
    V1 <- V1_new
    V2 <- V2_new
    j <- j + 1
  }

  return(list(V1, V2))
}

V_full <- V_full_func(
  vil_inc1, vil_P1, vil_inc2, vil_P2, g,
  vil_R, vil_S, vil_inc_ag, lambda_min, lambda_max, lambda,
  beta, sig,
  util, util_prime, cons1, cons2
)

V1_full <- V_full[[1]]
V2_full <- V_full[[2]]

```

## First-best risk sharing with migration

To obtain the value functions under first-best risk sharing without migration, assuming the equal Pareto weights, I use the following recursive equation:

$$
  V^i_{fb, mig}(s, \lambda) = E_q \left[ u \left( c_{it}(s, q, j(s, \lambda), \lambda) \right) - \mathcal{I}^i(j(s, \lambda)) d(z) + \beta E[V^i_{fb, mig}(s', \lambda)] \right],
$$

where $j(s, \lambda)$ is determined such that 

$$
  j(s, \lambda) = \arg \max_j \sum_i E_q \left[ u \left( c_{it}(s, q, j(s, \lambda), \lambda) \right) - \mathcal{I}^i(j(s, \lambda)) d(z) + \beta E[V^i_{fb, mig}(s', \lambda)] \right].
$$

Since the future value function does not depend on the current migration decision, this becomes

$$
  j(s, \lambda) = \arg \max_j \sum_i E_q \left[ u \left( c_{it}(s, q, j(s, \lambda), \lambda) \right) - \mathcal{I}^i(j(s, \lambda)) d(z) \right].
$$

Also, since $q$ and $s'$ are independent, the value function becomes

$$
  V^i_{fb, mig}(s, \lambda) = E_q \left[ u \left( c_{it}(s, q, j(s, \lambda), \lambda) \right) - \mathcal{I}^i(j(s, \lambda)) d(z) \right] + \beta E[V^i_{fb, mig}(s', \lambda)].
$$


```{r}

V_full_mig_func <- function(
  vil_inc1, vil_P1, vil_inc2, vil_P2, 
  vil_R, vil_S, vil_inc_ag, 
  mig_inc1, mig_P1, mig_inc2, mig_P2, 
  mig_R, mig_S, mig_inc_ag, mig_dec_mat,
  g, lambda_min, lambda_max, lambda,
  beta, sig, cons1, cons2,
  total_mig_inc, mig_cons1, mig_cons2,
  util, util_prime
  ) {

  # Value function iterations ================
  # Initial guess is the instantaneous utility under full risk sharing
  V1 <- util(cons1, sig)
  V2 <- util(cons2, sig)
  V1_new <- matrix(nrow = vil_S, ncol = (g + 1))
  V2_new <- matrix(nrow = vil_S, ncol = (g + 1))
  
  total_util_mat <- array(0, dim = c(vil_S, (g + 1), nrow(mig_dec_mat)))
  util1_mat <- array(0, dim = c(vil_S, (g + 1), nrow(mig_dec_mat)))
  util2_mat <- array(0, dim = c(vil_S, (g + 1), nrow(mig_dec_mat)))
  for (j in 1:nrow(mig_dec_mat)) {
    
    for (k in 1:mig_S) {
      total_util_mat[,,j] <- (util(mig_cons1[,k,j,], sig) + util(mig_cons2[,k,j,], sig)) * mig_R[k]
      util1_mat[,,j] <- util(mig_cons1[,k,j,], sig) * mig_R[k]
      util2_mat[,,j] <- util(mig_cons2[,k,j,], sig) * mig_R[k]
    }
    total_util_mat[,,j] <- total_util_mat[,,j] - sum(mig_dec_mat[j,]) * d
    util1_mat[,,j] <- util1_mat[,,j] - sum(mig_dec_mat[j,1]) * d
    util2_mat[,,j] <- util2_mat[,,j] - sum(mig_dec_mat[j,2]) * d
  }
  mig_dec <- apply(total_util_mat, c(1, 2), which.max)
  
  max_util1_mat <- matrix(nrow = vil_S, ncol = (g + 1))
  max_util2_mat <- matrix(nrow = vil_S, ncol = (g + 1))
  argmax_mig_dec_array <- array(NA, dim = c(vil_S, (g + 1), 2))
  for (s in 1:vil_S) {
    for (l in 1:(g + 1)) {
      max_util1_mat[s, l] <- util1_mat[s, l, mig_dec[s, l]]
      max_util2_mat[s, l] <- util2_mat[s, l, mig_dec[s, l]]
      argmax_mig_dec_array[s, l, ] <- mig_dec_mat[mig_dec[s, l], ]
    }
  }
  
  # Obtain value functions by value function iterations
  j <- 1
  diff <- 1
  while (diff > 1e-8 & j < 500) {
    V1_new <- max_util1_mat + beta * vil_R %*% V1
    V2_new <- max_util2_mat + beta * vil_R %*% V2
    diff <- max(max(abs(V1_new - V1)), max(abs(V2_new - V2)))
    V1 <- V1_new
    V2 <- V2_new
    j <- j + 1
  }
  
  return(list(V1, V2, mig_dec))
}

V_full_mig <- V_full_mig_func(
  vil_inc1, vil_P1, vil_inc2, vil_P2, 
  vil_R, vil_S, vil_inc_ag, 
  mig_inc1, mig_P1, mig_inc2, mig_P2, 
  mig_R, mig_S, mig_inc_ag, mig_dec_mat,
  g, lambda_min, lambda_max, lambda,
  beta, sig, cons1, cons2,
  total_mig_inc, mig_cons1, mig_cons2,
  util, util_prime
)

V1_full_mig <- V_full_mig[[1]]
V2_full_mig <- V_full_mig[[2]]
mig_dec_full <- V_full_mig[[3]]

```

## Before-migration value of autarky

```{r}

Omega_before_mig_func <- function(
  vil_inc1, vil_P1, vil_inc2, vil_P2, vil_R, vil_inc_mat, vil_S,
  mig_inc1, mig_P1, mig_inc2, mig_P2, mig_R, mig_inc_mat, mig_S,
  beta, sig, d,
  util, util_prime
  ) {
  
  # Expected utility under autarky for HH1
  Omega1_before_mig <- numeric(length = vil_S)
  i <- 1
  diff <- 1
  while (diff > 1e-12) {
    expected_mig_inc <- util(
      matrix(vil_inc_mat[,1], nrow = vil_S, ncol = mig_S) + 
        matrix(mig_inc_mat[,1], nrow = vil_S, ncol = mig_S, byrow = TRUE), 
      sig
      ) %*% mig_R - d
    Omega1_before_mig_new <- pmax(util(vil_inc_mat[,1], sig), expected_mig_inc) + beta * vil_R %*% Omega1_before_mig
    diff <- max(abs(Omega1_before_mig_new - Omega1_before_mig))
    Omega1_before_mig <- Omega1_before_mig_new
    i <- i + 1
  }

  # Expected utility under autarky for HH2
  Omega2_before_mig <- numeric(length = vil_S)
  i <- 1
  diff <- 1
  while (diff > 1e-12) {
    expected_mig_inc <- util(
      matrix(vil_inc_mat[,2], nrow = vil_S, ncol = mig_S) + 
        matrix(mig_inc_mat[,2], nrow = vil_S, ncol = mig_S, byrow = TRUE), 
      sig
      ) %*% mig_R - d
    Omega2_before_mig_new <- pmax(util(vil_inc_mat[,2], sig), expected_mig_inc) + beta * vil_R %*% Omega2_before_mig
    diff <- max(abs(Omega2_before_mig_new - Omega2_before_mig))
    Omega2_before_mig <- Omega2_before_mig_new
    i <- i + 1
  }

  return(cbind(Omega1_before_mig, Omega2_before_mig))
}

Omega_before_mig <- Omega_before_mig_func(
  vil_inc1, vil_P1, vil_inc2, vil_P2, vil_R, vil_inc_mat, vil_S,
  mig_inc1, mig_P1, mig_inc2, mig_P2, mig_R, mig_inc_mat, mig_S,
  beta, sig, d,
  util, util_prime
  )

Omega1_before_mig <- Omega_before_mig[,1]
Omega2_before_mig <- Omega_before_mig[,2]

```

## After-migration value of autarky

```{r}

Omega_after_mig_func <- function(
  vil_inc1, vil_P1, vil_inc2, vil_P2, vil_R, vil_inc_mat, vil_S,
  mig_inc1, mig_P1, mig_inc2, mig_P2, mig_R, mig_inc_mat, mig_S, mig_dec_mat,
  beta, sig, d,
  util, util_prime, Omega_before_mig
  ) {
  
  # Expected utility under autarky for HH1
  Omega1_after_mig <- array(0, dim = c(vil_S, mig_S, nrow(mig_dec_mat)))
  Omega1_after_mig_new <- array(0, dim = c(vil_S, mig_S, nrow(mig_dec_mat)))
  i <- 1
  diff <- 1
  while (diff > 1e-12) {
    mig_inc <- util(
      matrix(vil_inc_mat[,1], nrow = vil_S, ncol = mig_S) + 
        matrix(mig_inc_mat[,1], nrow = vil_S, ncol = mig_S, byrow = TRUE), 
      sig
      ) - d
    for (j in seq(nrow(mig_dec_mat))) {
      Omega1_after_mig_new[,,j] <- mig_dec_mat[j, 1] * mig_inc + 
        (1 - mig_dec_mat[j, 1]) * matrix(util(vil_inc_mat[,1], sig), nrow = vil_S, ncol = mig_S) + 
        matrix(beta * vil_R %*% Omega_before_mig[,1], nrow = vil_S, ncol = mig_S)
    }
    
    diff <- max(abs(Omega1_after_mig_new - Omega1_after_mig))
    Omega1_after_mig <- Omega1_after_mig_new
    i <- i + 1
  }

  # Expected utility under autarky for HH2
  Omega2_after_mig <- array(0, dim = c(vil_S, mig_S, nrow(mig_dec_mat)))
  Omega2_after_mig_new <- array(0, dim = c(vil_S, mig_S, nrow(mig_dec_mat)))
  i <- 1
  diff <- 1
  while (diff > 1e-12) {
    mig_inc <- util(
      matrix(vil_inc_mat[,2], nrow = vil_S, ncol = mig_S) + 
        matrix(mig_inc_mat[,2], nrow = vil_S, ncol = mig_S, byrow = TRUE), 
      sig
      ) - d
    for (j in seq(nrow(mig_dec_mat))) {
      Omega2_after_mig_new[,,j] <- mig_dec_mat[j, 2] * mig_inc + 
        (1 - mig_dec_mat[j, 2]) * matrix(util(vil_inc_mat[,2], sig), nrow = vil_S, ncol = mig_S) + 
        matrix(beta * vil_R %*% Omega_before_mig[,2], nrow = vil_S, ncol = mig_S)
    }
    
    diff <- max(abs(Omega2_after_mig_new - Omega2_after_mig))
    Omega2_after_mig <- Omega2_after_mig_new
    i <- i + 1
  }

  return(list(Omega1_after_mig, Omega2_after_mig))
}

Omega_after_mig <- Omega_after_mig_func(
  vil_inc1, vil_P1, vil_inc2, vil_P2, vil_R, vil_inc_mat, vil_S,
  mig_inc1, mig_P1, mig_inc2, mig_P2, mig_R, mig_inc_mat, mig_S, mig_dec_mat,
  beta, sig, d,
  util, util_prime, Omega_before_mig
  )

Omega1_after_mig <- Omega_after_mig[[1]]
Omega2_after_mig <- Omega_after_mig[[2]]

```

## Risk-sharing with limited commitment and migration

```{r}

cons1_lc <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat), (g + 1)))
cons2_lc <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat), (g + 1)))
V1_after_mig <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat), (g + 1)))
V2_after_mig <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat), (g + 1)))

after_mig_lambda_int <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat), 2))
after_mig_lambda <- array(NA, dim = c(vil_S, mig_S, nrow(mig_dec_mat), (g + 1)))

before_mig_lambda_int <- array(NA, dim = c(vil_S, 2))
before_mig_lambda <- array(NA, dim = c(vil_S, (g + 1)))

V_before_mig_update_func <- function(
  V1_before_mig, V2_before_mig,
  vil_inc1, vil_P1, vil_inc2, vil_P2, vil_R, vil_inc_mat, vil_S,
  mig_inc1, mig_P1, mig_inc2, mig_P2, mig_R, mig_inc_mat, mig_S, mig_dec_mat,
  beta, sig, d,
  util, util_prime, Omega_before_mig,
  con1_lc, con2_lc, V1_after_mig, V2_after_mig,
  after_mig_lambda_int, after_mig_lambda, before_mig_lambda_int, before_mig_lambda,
  kappa = 1e-1
) {
  
  # Value functions after migration at grid point (s, q, j, lambda) =================
  for (q in 1:mig_S) {
    for (j in 1:nrow(mig_dec_mat)) {
      V1_after_mig[,q,j,] <- util(mig_cons1, sig)[,q,j,] - 
        mig_dec_mat[j, 1] * d + beta * vil_R %*% V1_before_mig
      V2_after_mig[,q,j,] <- util(mig_cons2, sig)[,q,j,] - 
        mig_dec_mat[j, 2] * d + beta * vil_R %*% V2_before_mig
    }
  }
  
  # find the after-migration intervals
  for (s in 1:vil_S) {
    for (q in 1:mig_S) {
      for (j in 1:nrow(mig_dec_mat)) {
        
        # Function to calculate the difference between 
        # the after-migration value when the relative Pareto weight is x
        # and the after-migration autarky value for HH1
        calc_diff_val_aut_1 <- function(x) {
          # Calculate consumption of HH 1 at a relative Pareto weight x
          cons_x <- total_mig_inc[s, q, j] / (1 + x^(- 1 / sig))
          
          # Value functions of HH 1 under the relative Pareto weights x
          # (I use interpolation since x might not be on the grid lambda)
          V1_x <- apply(V1_before_mig, 1, function(y) approxfun(lambda, y, rule = 2)(x))
          
          # difference between after-migration value function under x and 
          # after-migration autarky value
          diff <- util(cons_x, sig) - mig_dec_mat[j, 1] * d + beta * vil_R[s,] %*% V1_x - Omega1_after_mig[s, q, j]
          return(diff)
        }
        
        # Function to calculate the difference between 
        # the after-migration value when the relative Pareto weight is x
        # and the after-migration autarky value for HH2
        calc_diff_val_aut_2 <- function(x) {
          # Calculate consumption of HH 1 at a relative Pareto weight x
          cons_x <- total_mig_inc[s, q, j] - total_mig_inc[s, q, j] / (1 + x^(- 1 / sig))
          
          # Value functions of HH 2 under the relative Pareto weights x
          # (I use interpolation since x might not be on the grid lambda)
          V2_x <- apply(V2_before_mig, 1, function(y) approxfun(lambda, y, rule = 2)(x))
          
          # difference between after-migration value function under x and 
          # after-migration autarky value
          diff <- util(cons_x, sig) - mig_dec_mat[j, 2] * d + beta * vil_R[s,] %*% V2_x - Omega2_after_mig[s, q, j]
          return(diff)
        }
        
        # If the relative Pareto weight is too low and violates the PC, then
        # set the relative Pareto weight to the lower bound of the interval, and
        # HH1 gets the value under autarky.
        if (
          (calc_diff_val_aut_1(lambda_max) > 0) && 
          (calc_diff_val_aut_1(lambda_min) < 0)
          ) {
          
          x_low <- uniroot(
            calc_diff_val_aut_1, c(lambda_min, lambda_max), 
            tol = 1e-10, maxiter = 1000
            )$root
          after_mig_lambda_int[s, q, j, 1] <- x_low
          
          # Index of the point on the grid of 
          # relative Pareto weights (lambda) closest to x_low
          lambda_ind_low <- which.min(abs(x_low - lambda))
          if (x_low > lambda[lambda_ind_low]) {
            lambda_ind_low <- lambda_ind_low + 1
          }
          after_mig_lambda[s, q, j, 1:lambda_ind_low] <- x_low
          
          # Value functions of HH 2 under the relative Pareto weights x
          # (I use interpolation since x_low might not be on the grid q)
          V2_x <- apply(
            V2_before_mig, 1, 
            function(y) approxfun(lambda, y, rule = 2)(x_low)
            )
          
          # Calculate consumption at a relative Pareto weight x_low
          cons1_x_low <- total_mig_inc[s,q,j] / (1 + x_low^(- 1 / sig))
          cons2_x_low <- total_mig_inc[s,q,j] - cons1_x_low
          
          cons1_lc[s, q, j, 1:lambda_ind_low] <- cons1_x_low
          cons2_lc[s, q, j, 1:lambda_ind_low] <- cons2_x_low
          V1_after_mig[s, q, j, 1:lambda_ind_low] <- Omega1_after_mig[s, q, j]
          V2_after_mig[s, q, j, 1:lambda_ind_low] <- util(cons2_x_low, sig) - 
            mig_dec_mat[j, 2] * d + beta * vil_R[s,] %*% V2_x
        } else if (calc_diff_val_aut_1(lambda_max) <= 0) {
          # print(c(s, q, j))
          V1_after_mig[s, q, j,] <- Omega1_after_mig[s, q, j]
          V2_after_mig[s, q, j,] <- Omega2_after_mig[s, q, j]
          after_mig_lambda_int[s, q, j, 1]  <- lambda_max
          after_mig_lambda[s, q, j,] <- lambda_max
          lambda_ind_low <- g + 2
        } else if (calc_diff_val_aut_1(lambda_min) >= 0) {
          after_mig_lambda_int[s, q, j, 1] <- lambda_min
          after_mig_lambda[s, q, j,] <- lambda_min
          lambda_ind_low <- 0
        }
      
        # If the relative Pareto weight is too high and violates the PC, then
        # set the relative Pareto weight to the upper bound of the interval, and
        # HH2 gets the value under autarky.
        if (lambda_ind_low <= (g + 1)) {
          if (
            (calc_diff_val_aut_2(lambda_min) > 0) && 
            (calc_diff_val_aut_2(lambda_max) < 0)
            ) {
            
            x_high <- uniroot(
              calc_diff_val_aut_2, c(lambda_min, lambda_max), 
              tol = 1e-10, maxiter = 1000
              )$root
            after_mig_lambda_int[s, q, j, 2] <- x_high
            
            # Index of the point on the grid of 
            # relative Pareto weights (lambda) closest to x_high
            lambda_ind_high <- which.min(abs(x_high - lambda))
            if (x_high > lambda[lambda_ind_high]) {
              lambda_ind_high <- lambda_ind_high + 1
            }
            after_mig_lambda[s, q, j, lambda_ind_high:(g + 1)] <- x_high
            
            # Value functions of HH 2 under the relative Pareto weights x
            # (I use interpolation since x_high might not be on the grid q)
            V1_x <- apply(
              V1_before_mig, 1, 
              function(y) approxfun(lambda, y, rule = 2)(x_high)
              )
            
            # Calculate consumption of HH 1 at a relative Pareto weight x_high
            cons1_x_high <- total_mig_inc[s, q, j] / (1 + x_high^(- 1 / sig))
            cons2_x_high <- total_mig_inc[s, q, j] - cons1_x_high
            
            cons1_lc[s, q, j, lambda_ind_high:(g + 1)] <- cons1_x_high
            cons2_lc[s, q, j, lambda_ind_high:(g + 1)] <- cons2_x_high
            V1_after_mig[s, q, j, lambda_ind_high:(g + 1)] <- util(cons1_x_high, sig) - 
              mig_dec_mat[j, 1] * d + beta * vil_R[s,] %*% V1_x
            V2_after_mig[s, q, j, lambda_ind_high:(g + 1)] <- Omega2_after_mig[s, q, j]
          } else if (calc_diff_val_aut_2(lambda_min) <= 0) {
            V1_after_mig[s, q, j,] <- Omega1_after_mig[s, q, j]
            V2_after_mig[s, q, j,] <- Omega2_after_mig[s, q, j]
            after_mig_lambda_int[s, q, j, 2] <- lambda_min
            after_mig_lambda[s, q, j,] <- lambda_min
            lambda_ind_high <- 0
          } else if (calc_diff_val_aut_2(lambda_max) >= 0) {
            after_mig_lambda_int[s, q, j, 2] <- lambda_max
            after_mig_lambda[s, q, j,] <- lambda_max
            lambda_ind_high <- g + 2
          }
        }
      }
    }
  }
  
  
  # Value functions before migration at grid point (s, lambda) =================
  # expected value functions at each migration decision
  exp_V1_mig <- array(NA, dim = c(vil_S, (g + 1), nrow(mig_dec_mat)))
  exp_V2_mig <- array(NA, dim = c(vil_S, (g + 1), nrow(mig_dec_mat)))
  for (s in 1:vil_S) {
    for (l in 1:(g + 1)) {
      exp_V1_mig[s, l, ] <- mig_R %*% V1_after_mig[s,,,l]
      exp_V2_mig[s, l, ] <- mig_R %*% V2_after_mig[s,,,l]
    }
  }
  exp_V_mig <- exp_V1_mig + exp_V2_mig
  
  # smoothed migration vector at grid points (s, lambda, j)
  smoothed_mig_dec <- array(NA, dim = c(vil_S, (g + 1), nrow(mig_dec_mat)))
  scaled_exp_V_mig <- array(NA, dim = c(vil_S, (g + 1), nrow(mig_dec_mat)))
  max_exp_V_mig <- apply(exp_V_mig, c(1, 2), max)
  for (j in 1:nrow(mig_dec_mat)) {
    scaled_exp_V_mig[,,j] <- exp_V_mig[,,j] - max_exp_V_mig
  }
  for (j in 1:nrow(mig_dec_mat)) {
    smoothed_mig_dec[,,j] <- (exp((exp_V_mig[,,j] - max_exp_V_mig) / kappa)) / 
      apply(exp((scaled_exp_V_mig) / kappa), c(1, 2), sum)
  }
  
  # before-migration value functions (before checking the enforceability)
  V1_before_mig_new <- apply(smoothed_mig_dec * exp_V1_mig, c(1, 2), sum)
  V2_before_mig_new <- apply(smoothed_mig_dec * exp_V2_mig, c(1, 2), sum)
  
  # find the before-migration intervals
  for (s in 1:vil_S) {
    # Function to calculate the difference between 
    # the before-migration value when the relative Pareto weight is x
    # and the before-migration autarky value for HH1
    calc_diff_val_aut_1 <- function(x) {
      # Value functions of HH 1 under the relative Pareto weights x
      # (I use interpolation since x might not be on the grid lambda)
      V1_x <- approxfun(lambda, V1_before_mig[s,], rule = 2)(x)
      
      # difference between before-migration value function under x and 
      # before-migration autarky value
      diff <- V1_x - Omega1_before_mig[s]
      return(diff)
    }
    
    # Function to calculate the difference between 
    # the before-migration value when the relative Pareto weight is x
    # and the before-migration autarky value for HH2
    calc_diff_val_aut_2 <- function(x) {
      # Value functions of HH 2 under the relative Pareto weights x
      # (I use interpolation since x might not be on the grid lambda)
      V2_x <- approxfun(lambda, V2_before_mig[s,], rule = 2)(x)
      
      # difference between before-migration value function under x and 
      # before-migration autarky value
      diff <- V2_x - Omega2_before_mig[s]
      return(diff)
    }
    
    # print(c(calc_diff_val_aut_1(lambda_min), calc_diff_val_aut_1(lambda_max)))
    # print(c(calc_diff_val_aut_2(lambda_min), calc_diff_val_aut_2(lambda_max)))
    
    # If the relative Pareto weight is too low and violates the PC, then
    # set the relative Pareto weight to the lower bound of the interval, and
    # HH1 gets the value under autarky.
    if (
      (calc_diff_val_aut_1(lambda_max) > 0) && 
      (calc_diff_val_aut_1(lambda_min) < 0)
      ) {
      
      x_low <- uniroot(
        calc_diff_val_aut_1, c(lambda_min, lambda_max), 
        tol = 1e-10, maxiter = 1000
        )$root
      before_mig_lambda_int[s, 1] <- x_low
      
      # Index of the point on the grid of 
      # relative Pareto weights (lambda) closest to x_low
      lambda_ind_low <- which.min(abs(x_low - lambda))
      if (x_low > lambda[lambda_ind_low]) {
        lambda_ind_low <- lambda_ind_low + 1
      }
      before_mig_lambda[s, 1:lambda_ind_low] <- x_low
      
      # Value functions of HH 2 under the relative Pareto weights x_low
      exp_V2_x <- mig_R %*% V2_after_mig[s,,,lambda_ind_low]
      V2_x <- sum(smoothed_mig_dec[s,lambda_ind_low,] * exp_V2_x)
      
      V1_before_mig_new[s, 1:lambda_ind_low] <- Omega1_before_mig[s]
      V2_before_mig_new[s, 1:lambda_ind_low] <- V2_x
    } else if (calc_diff_val_aut_1(lambda_max) <= 0) {
      # print("calc_diff_val_aut_1(lambda_max) <= 0")
      V1_before_mig_new[s,] <- Omega1_before_mig[s]
      V2_before_mig_new[s,] <- Omega2_before_mig[s]
      before_mig_lambda_int[s, 1]  <- lambda_max
      before_mig_lambda[s,] <- lambda_max
      lambda_ind_low <- g + 2
    } else if (calc_diff_val_aut_1(lambda_min) >= 0) {
      # print("calc_diff_val_aut_1(lambda_min) >= 0")
      before_mig_lambda_int[s, 1] <- lambda_min
      before_mig_lambda[s,] <- lambda_min
      lambda_ind_low <- 0
    }
  
    # If the relative Pareto weight is too high and violates the PC, then
    # set the relative Pareto weight to the upper bound of the interval, and
    # HH2 gets the value under autarky.
    if (lambda_ind_low <= (g + 1)) {
      if (
        (calc_diff_val_aut_2(lambda_min) > 0) && 
        (calc_diff_val_aut_2(lambda_max) < 0)
        ) {
        
        x_high <- uniroot(
          calc_diff_val_aut_2, c(lambda_min, lambda_max), 
          tol = 1e-10, maxiter = 1000
          )$root
        before_mig_lambda_int[s, 2] <- x_high
        
        # Index of the point on the grid of 
        # relative Pareto weights (lambda) closest to x_high
        lambda_ind_high <- which.min(abs(x_high - lambda))
        if (x_high > lambda[lambda_ind_high]) {
          lambda_ind_high <- lambda_ind_high + 1
        }
        before_mig_lambda[s, lambda_ind_high:(g + 1)] <- x_high
        
        # Value functions of HH 2 under the relative Pareto weights x
        # (I use interpolation since x_high might not be on the grid q)
        exp_V1_x <- mig_R %*% V1_after_mig[s,,,lambda_ind_high]
        V1_x <- sum(smoothed_mig_dec[s,lambda_ind_high,] * exp_V1_x)
        
        V1_before_mig_new[s, lambda_ind_high:(g + 1)] <- V1_x
        V2_before_mig_new[s, lambda_ind_high:(g + 1)] <- Omega2_before_mig[s]
      } else if (calc_diff_val_aut_2(lambda_min) <= 0) {
        # print("calc_diff_val_aut_2(lambda_min) <= 0")
        V1_before_mig_new[s,] <- Omega1_before_mig[s]
        V2_before_mig_new[s,] <- Omega2_before_mig[s]
        before_mig_lambda_int[s, 2] <- lambda_min
        before_mig_lambda[s,] <- lambda_min
        lambda_ind_high <- 0
      } else if (calc_diff_val_aut_2(lambda_max) >= 0) {
        # print("calc_diff_val_aut_2(lambda_max) >= 0")
        before_mig_lambda_int[s, 2] <- lambda_max
        before_mig_lambda[s,] <- lambda_max
        lambda_ind_high <- g + 2
      }
    }
  }
  
  return(
    list(
      V1_before_mig_new, V2_before_mig_new, 
      before_mig_lambda_int, after_mig_lambda_int
      )
    )
  
  }


V1_before_mig <- pmax(V1_full, outer(Omega1_before_mig, rep(1, (g + 1))))
V2_before_mig <- pmax(V2_full, outer(Omega2_before_mig, rep(1, (g + 1))))
# V1_before_mig <- V1_full
# V2_before_mig <- V2_full
# V1_before_mig <- V1_full_mig
# V2_before_mig <- V2_full_mig

i <- 1
diff <- 1
while ((diff > 1e-5) & (i <= 500)) {
  
  update_output <- V_before_mig_update_func(
    V1_before_mig, V2_before_mig,
    vil_inc1, vil_P1, vil_inc2, vil_P2, vil_R, vil_inc_mat, vil_S,
    mig_inc1, mig_P1, mig_inc2, mig_P2, mig_R, mig_inc_mat, mig_S, mig_dec_mat,
    beta, sig, d,
    util, util_prime, Omega_before_mig,
    con1_lc, con2_lc, V1_after_mig, V2_after_mig,
    after_mig_lambda_int, after_mig_lambda, before_mig_lambda_int, before_mig_lambda
  )
  
  diff <- max(abs(V1_before_mig - update_output[[1]]), abs(V2_before_mig - update_output[[2]]))
  
  V1_before_mig <- update_output[[1]]
  V2_before_mig <- update_output[[2]]
  
  i <- i + 1
  
  if (i %% 10 == 0) {
    print(diff)
    print(update_output[[3]])
  }
}


update_output[[3]]

```




