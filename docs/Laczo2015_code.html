<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Mizuhiro Suzuki" />

<meta name="date" content="2020-10-18" />

<title>Dynamic limited commitment model in Laczó (2015)</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
      </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Risk Sharing</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="RiskSharingLit.html">Literature</a>
</li>
<li>
  <a href="CR93_code.html">Coate and Ravallion (1993)</a>
</li>
<li>
  <a href="LTW_code.html">Ligon et al. (2002)</a>
</li>
<li>
  <a href="Laczo2015_code.html">Laczó (2015)</a>
</li>
<li>
  <a href="TW88_code.html">Thomas and Worrall (1988)</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Dynamic limited commitment model in Laczó (2015)</h1>
<h4 class="author">Mizuhiro Suzuki</h4>
<h4 class="date">10/18/2020</h4>

</div>


<div id="model" class="section level2">
<h2>Model</h2>
<p>In this document, I consider a problem of two households, unlike the model in <span class="citation">Laczó (2015)</span> that considers many households in a village. As in other studies, <span class="citation">Laczó (2015)</span> considers the constrained-efficient consumptioon alocatinos. The social planner solves the following problem:</p>
<p><span class="math display">\[\begin{align*}
  &amp;\max_{\{c_{it}(s^t)\}} \sum_i \lambda_i \sum_{t = 1}^{\infty} \sum_{s^t} \delta^t \pi(s^t) u_i(c_{it}(s^t)) \\
  \text{subject to} 
  &amp;\sum_i c_{it} (s^t) \le \sum_i y_{it}(s_t) \quad \forall s^t, \forall t \\
  &amp;\sum_{r = t}^{\infty} \sum_{s^r} \delta^{r - t} \pi(s^r | s^t) u_i(c_{ir}(s^r)) \ge U_{i}^{aut}(s_t) \quad \forall s^t, \forall t, \forall i.
\end{align*}\]</span></p>
<p>Here, the income follows a Markov process and is independent across households. Notice the difference between the history of states up to period <span class="math inline">\(t\)</span> (<span class="math inline">\(s^t\)</span>) and the state at period <span class="math inline">\(t\)</span> (<span class="math inline">\(s_t\)</span>). The variable <span class="math inline">\(\lambda_i\)</span> is the Pareto weight of a household <span class="math inline">\(i\)</span>. The last equation is the participation constraints (PCs), whose RHS is the value of autarky and the solution of the following Bellman equation:</p>
<p><span class="math display">\[
  U_i^{aut}(s_t) = u_i((1 - \phi) y_{it}(s_t)) + \delta \sum_{s^{t + 1}} \pi(s_{t + 1} | s_t) U_{i}^{aut}(s_{t + 1}),
\]</span> where <span class="math inline">\(\phi\)</span> is the punishment of renege, which is a fraction of consumption each period. It is assumed that savings are absent.</p>
<p>Letting the multiplier on the PC of <span class="math inline">\(i\)</span> be <span class="math inline">\(\delta^t \pi(s^t) \mu_i(s^t)\)</span> andd the multiplier on the aggregate resource constraint be <span class="math inline">\(\delta^t \pi(s^t) \rho(s^t)\)</span>, the Lagrangian is</p>
<p><span class="math display">\[
  \sum_{t = 1}^{\infty} \sum_{s^t} \delta^t \pi(s^t) \left\{ \sum_i \left[ \lambda_i u_i(c_{it}(s^t)) + \mu_i(s^t) \left( \sum_{r = t}^{\infty} \sum_{s^r} \delta^{r - t} \pi(s^r | s^t) u_i (c_{ir} (s^r)) - U_i^{aut}(s_t) \right) \right] + \rho(s^t) \left( \sum_i \left(y_{it} (s_t) - c_{it} (s^t) \right) \right) \right\}
\]</span> With the recursive method in <span class="citation">Marcet and Marimon (2019)</span>, this Lagrangian can be written as</p>
<p><span class="math display">\[
  \sum_{t = 1}^{\infty} \sum_{s^t} \delta^t \pi(s^t) \left\{ \sum_i \left[ M_i (s^{t - 1}) u_i (c_{it} (s^t)) + \mu_i (s^t) (u_i (c_{it} (s^t)) - U_i^{aut} (s_t)) \right] + \rho(s^t) \left( \sum_i \left( y_{it}(s_t) - c_{it} (s^t) \right) \right) \right\},
\]</span></p>
<p>where <span class="math inline">\(M_i(s^t) = M_i(s^{t - 1}) + \mu_i(s^t)\)</span> and <span class="math inline">\(M_i(s^0) = \lambda\)</span>. The variable <span class="math inline">\(M_i(s^t)\)</span> is the current Pareto weight of household <span class="math inline">\(i\)</span> and is equal to its initial Pareto weight plus the sum of the Lagrange mulipliers on its PCs along the history <span class="math inline">\(s^t\)</span>.</p>
<p>Let <span class="math inline">\(x_i(s^t) = \frac{M_i(s^t)}{M_v(s^t)}\)</span>, the relative Pareto weight of household <span class="math inline">\(i\)</span> under the history <span class="math inline">\(s^t\)</span>, where the weight of household <span class="math inline">\(v\)</span> is normalized to <span class="math inline">\(1\)</span>. Then, the vector of relative weights <span class="math inline">\(x(s^t)\)</span> plays as a role as a co-state variable, and the solution consists of policy functions <span class="math inline">\(x_{it}(s_t, x_{t - 1})\)</span> and <span class="math inline">\(c_{it}(s_t, x_{t - 1})\)</span>. That is, <span class="math inline">\(x_{t - 1}\)</span> is a sufficient statistic for the history up to <span class="math inline">\(t - 1\)</span>. The optimality condition is</p>
<p><span class="math display">\[
  \frac{u_v&#39;(c_{vt}(s_t, x_{t - 1}))}{u_i&#39;(c_{it}(s_t, x_{t - 1}))} = x_{it}(s_t, x_{t - 1}) \quad \forall i.
\]</span></p>
<p>The value functioon can be written recursively as</p>
<p><span class="math display">\[
  V_i(s_t, x_{t - 1}) = u_i (c_{it} (s_t, x_{t - 1})) + \delta \sum_{s_{t + 1}} \pi(s_{t + 1} | s_t) V_i (s_{t + 1}, x_t(s_t, x_{t - 1})).
\]</span></p>
<p><span class="citation">(<span class="citeproc-not-found" data-reference-id="Ligon2015"><strong>???</strong></span>)</span> argues that, as in <span class="citation">Ligon, Thomas, and Worrall (2002)</span>, the evolution of relative Pareto weights is fully characterized by state-dependent intervals, which give the weights in the case where PCs are binding.</p>
</div>
<div id="computation" class="section level2">
<h2>Computation</h2>
<p>In this section I conduct a numerical exercise to compute value functions under the limited commitment model with heterogeneous risk preferences.</p>
<div id="model-settings" class="section level3">
<h3>Model settings</h3>
<p>I simplify the model of <span class="citation">Laczó (2015)</span> and consider two households with <span class="math inline">\(2 \times 2\)</span> states. The income process are iid:</p>
<p><span class="math display">\[
  y_1 = [2/3, 4/3],\ y_2 = [2/3, 4/3], \\
  \pi_1 = [0.1, 0.9],\ \pi_2 = [0.1, 0.9].
\]</span></p>
<pre class="r"><code># income shocks and their transition probabilities of the household
inc1 &lt;- c(2/3, 4/3)
P1 &lt;- matrix(rep(c(0.1, 0.9), 2), nrow = 2, byrow = TRUE)

# income shocks and their transition probabilities of the village
inc2 &lt;- c(2/3, 4/3)
P2 &lt;- matrix(rep(c(0.1, 0.9), 2), nrow = 2, byrow = TRUE)

# transition super-matrix of income shocks
R &lt;- kronecker(P2, P1)

# number of states
# (number of income states for a household times
# number of income states for the village)
S &lt;- length(inc1) * length(inc2)

# Income matrix
# (col 1: HH income, col 2: village income)
inc_mat &lt;- as.matrix(expand.grid(inc1, inc2))

# Aggregate income in each state
inc_ag &lt;- rowSums(inc_mat)</code></pre>
<p>I assume the CRRA utility functions:</p>
<p><span class="math display">\[
  u_i(c_{it}) = \frac{c_{it}^{1 - \sigma_i} - 1}{1 - \sigma_i}.
\]</span></p>
<pre class="r"><code># Define utility function
util &lt;- function(c, sigma) {
  if (sigma != 1) {
    output = (c ^ (1 - sigma) - 1) / (1 - sigma)
  } else {
    output = log(c)
  }
  return(output)
}
util_prime &lt;- function(c, sigma) c ^ (- sigma)</code></pre>
</div>
<div id="value-of-autarky" class="section level3">
<h3>Value of autarky</h3>
<pre class="r"><code>delta &lt;- 0.9 # time discount factor 
sigma1 &lt;- 1.0 # coefficient of relative risk aversion of HH1
sigma2 &lt;- 1.0 # coefficient of relative risk aversion of HH2
pcphi &lt;- 0.0 # punishment under autarky

# Expected utility under autarky for HH
U1_aut &lt;- numeric(length = length(inc1))
i &lt;- 1
diff &lt;- 1
while (diff &gt; 1e-8) {
  U1_aut_new &lt;- util((inc1 * (1 - pcphi)), sigma1) + delta * P1 %*% U1_aut
  diff &lt;- max(abs(U1_aut_new - U1_aut))
  U1_aut &lt;- U1_aut_new
  i &lt;- i + 1
}

# Expected utility under autarky for village
U2_aut &lt;- numeric(length = length(inc2))
i &lt;- 1
diff &lt;- 1
while (diff &gt; 1e-8) {
  U2_aut_new &lt;- util((inc2 * (1 - pcphi)), sigma2) + delta * P2 %*% U2_aut
  diff &lt;- max(abs(U2_aut_new - U2_aut))
  U2_aut &lt;- U2_aut_new
  i &lt;- i + 1
}

# Since in this case the income process are iid, 
# values under autarky can be computed in the following way:
# U1_out = util((1 - pcphi) * inc1, sigma1) + delta / (1 - delta) * P1 %*% util((1 - pcphi) * inc1, sigma1)
# U2_out = util((1 - pcphi) * inc2, sigma2) + delta / (1 - delta) * P2 %*% util((1 - pcphi) * inc2, sigma2)
# This way does not work when income processes are autocorrelated, as in the original model of Laczo (2015)

# Matrix of expected utilities of autarky
# (col 1: HH, col 2: village)
Uaut &lt;- expand.grid(U1_aut, U2_aut)</code></pre>
</div>
<div id="grid-of-relative-pareto-weights-and-consumption-on-the-grid-points" class="section level3">
<h3>Grid of relative Pareto weights and consumption on the grid points</h3>
<p>Here, I make the grid of relative Pareto weight of household 1, <span class="math inline">\(x(s^t)\)</span>, on which I compute the values (I use the notation <span class="math inline">\(x(s^t)\)</span> rather than <span class="math inline">\(x_i(s^t)\)</span> since there are only two households). The number of grid points is <span class="math inline">\(200\)</span>.</p>
<pre class="r"><code># (Number of grid points on relative Pareto weight) - 1
g &lt;- 199

# The grid points of relative Pareto weights
qmin &lt;- util_prime(max(inc2), sigma2) / util_prime(min(inc1 * (1 - pcphi)), sigma1)
qmax &lt;- util_prime(min(inc2 * (1 - pcphi)), sigma2) / util_prime(max(inc1), sigma1)
q &lt;- exp(seq(log(qmin), log(qmax), length.out = (g + 1)))</code></pre>
<p>Then, I compute consumptions of the household 1 on these grid points. From the optimality condition and the CRRA utility functions, we obtain</p>
<p><span class="math display">\[
  \frac{(y_{1t} + y_{2t} - c_{1t})^{- \sigma_2}}{c_{1t}^{- \sigma_1}} = x_{t}.
\]</span></p>
<p>Since there is no closed form solution for this, I derive <span class="math inline">\(c_{1t}\)</span> numerically:</p>
<pre class="r"><code># The grid points of consumption of HH 1
# Consumption is determined by aggregate income (inc_ag) and
# relative Pareto weights (q)
cons1 &lt;- matrix(nrow = S, ncol = (g + 1))
for (k in 1:S) {
  for (l in 1:(g + 1)) {
    f = function(w) util_prime((inc_ag[k] - w), sigma2) - q[l] * util_prime(w, sigma1)
    v = uniroot(f, c(1e-5, (inc_ag[k] - 1e-5)), tol = 1e-8, maxiter = 100)
    cons1[k, l] &lt;- v$root
  }
}</code></pre>
</div>
<div id="values-under-risk-sharing-full" class="section level3">
<h3>Values under risk-sharing (full)</h3>
<p>Now, I compute the values under full risk-sharing, which will be used as the initial values in value function iterations under the limited commitment model. Note that, under full risk sharing, the consumption only depends on the aggregate resources and time-invariate relative Pareto weights. Hence, I numerically solve the following Bellman equation:</p>
<p><span class="math display">\[
  V_i^{full}(s_t, x) = u_i(c_{it}(s_t, x)) + \delta \sum_{s^{t + 1}} \pi(s_{t + 1} | s_t) V_{i}^{full}(s_{t + 1}, x).
\]</span></p>
<pre class="r"><code># Initial guess is expected utilities under autarky
V1 &lt;- outer(Uaut[, 1], rep(1, (g + 1)))
V2 &lt;- outer(Uaut[, 2], rep(1, (g + 1)))
V1_new &lt;- matrix(nrow = S, ncol = (g + 1))
V2_new &lt;- matrix(nrow = S, ncol = (g + 1))

# Obtain value functions by value function iterations
j &lt;- 1
diff &lt;- 1
while (diff &gt; 1e-8 &amp; j &lt; 500) {
  V1_new &lt;- util(cons1, sigma1) + delta * R %*% V1
  V2_new &lt;- util(inc_ag - cons1, sigma2) + delta * R %*% V2
  diff &lt;- max(max(abs(V1_new - V1)), max(abs(V2_new - V2)))
  V1 &lt;- V1_new
  V2 &lt;- V2_new
  j &lt;- j + 1
}

V1_full &lt;- V1
V2_full &lt;- V2</code></pre>
</div>
<div id="values-under-risk-sharing-limited-commitment" class="section level3">
<h3>Values under risk-sharing (limited commitment)</h3>
<p>Next, I derive the state-dependent intervals of relative Pareto weights and calculate values under the model of limited commitment. To derive the intervals, I use the fact that at the limits of the intervals, the PCs are binding. For instance, to compute the lower limit <span class="math inline">\(\underline{x}^h(s)\)</span>, where <span class="math inline">\(h\)</span> indicates <span class="math inline">\(h\)</span>’th iteration, the PC of the household 1 is binding:</p>
<p><span class="math display">\[
  u_i(c_i^h(s)) + \delta \sum_{s&#39;} \pi(s&#39; | s) V_i^{h - i} (s&#39;, \underline{x}^h(s)) = U_i^{aut}(s),
\]</span> where the optimality condition is</p>
<p><span class="math display">\[
  \frac{u_2&#39;(c_{2}^h(s))}{u_1&#39;(c_{1}(s))} = \underline{x}^h(s).
\]</span></p>
<p>Notice that, once the PC binds, the past history, which is summarized by <span class="math inline">\(x_{t - 1}\)</span>, does not matter. This property is called “amnesia” (<span class="citation">Kocherlakota (1996)</span>).</p>
<pre class="r"><code># Initial guess is expected utilities under full risk sharing
V1 &lt;- V1_full
V2 &lt;- V2_full
V1_new &lt;- matrix(nrow = S, ncol = (g + 1))
V2_new &lt;- matrix(nrow = S, ncol = (g + 1))

cons1_lc &lt;- matrix(nrow = S, ncol = (g + 1)) # consumption of HH 1 under LC
x_lc &lt;- matrix(nrow = S, ncol = (g + 1)) # relative Pareto weights under LC
x_int &lt;- matrix(nrow = S, ncol = 2) # matrix of bounds of intervals

diff &lt;- 1
iter &lt;- 1
while (diff &gt; 1e-5) {
  # First, ignore enforceability and just update the value functions
  # using the values at the previous iteration
  V1_new &lt;- util(cons1, sigma1) + delta * R %*% V1
  V2_new &lt;- util(inc_ag - cons1, sigma2) + delta * R %*% V2
  
  # Now check enforceability at each state
  for (k in 1:S) {
    
    # This function calculate the difference between the value when the relative Pareto weight is x
    # and the value of autarky. This comes from the equation (1) in the supplementary material of
    # Laczo (2015). Used to calculate the lower bound of the interval.
    calc_diff_val_aut_1 &lt;- function(x) {
      # Calculate consumption of HH 1 at a relative Pareto weight x
      f &lt;- function(w) util_prime(inc_ag[k] - w, sigma2) / util_prime(w, sigma1) - x
      cons_x &lt;- uniroot(f, c(1e-6, (inc_ag[k] - 1e-6)), tol = 1e-8, maxiter = 100)$root
      
      # Index of the point on the grid of relative Pareto weights (q) closest to x
      q_ind &lt;- which.min(abs(x - q))
      if (x &gt; q[q_ind]) {
        q_ind &lt;- q_ind + 1
      }
      
      # Value functions of HH 1 under the relative Pareto weights x
      # (I use interpolation since x might not be on the grid q)
      V1_x &lt;- apply(V1, 1, function(y) approxfun(q, y, rule = 2)(x))
      
      # difference between 
      diff &lt;- util(cons_x, sigma1) + delta * R[k,] %*% V1_x - Uaut[k, 1]
      return(diff)
    }
    
    # Similarly, this function is used to calculate the upper bound.
    calc_diff_val_aut_2 &lt;- function(x) {
      # Calculate consumption of HH 1 at a relative Pareto weight x
      f &lt;- function(w) util_prime(inc_ag[k] - w, sigma2) / util_prime(w, sigma1) - x
      cons_x &lt;- uniroot(f, c(1e-6, (inc_ag[k] - 1e-6)), tol = 1e-8, maxiter = 100)$root
      
      # Index of the point on the grid of relative Pareto weights (q) closest to x
      q_ind &lt;- which.min(abs(x - q))
      if (x &gt; q[q_ind]) {
        q_ind &lt;- q_ind + 1
      }
      
      # Value functions of HH 1 under the relative Pareto weights x
      # (I use interpolation since x might not be on the grid q)
      V2_x &lt;- apply(V2, 1, function(y) approxfun(q, y, rule = 2)(x))
      
      # difference between 
      diff &lt;- util(inc_ag[k] - cons_x, sigma2) + delta * R[k,] %*% V2_x - Uaut[k, 2]
      return(diff)
    }   
    
    # If the relative Pareto weight is too low and violates the PC, then
    # set the relative Pareto weight to the lower bound of the interval, and
    # HH1 gets the value under autarky.
    if ((calc_diff_val_aut_1(qmax) &gt; 0) &amp;&amp; calc_diff_val_aut_1(qmin) &lt; 0) {
      
      # Derive the relative Pareto weight that satisfies the equation (1)
      # in the supplementary material of Laczo (2015)
      x_low &lt;- uniroot(calc_diff_val_aut_1, c(qmin, qmax), tol = 1e-8, maxiter = 100)$root
      x_int[k, 1] &lt;- x_low
      
      # Index of the point on the grid of relative Pareto weights (q) closest to x_low
      q_ind_low &lt;- which.min(abs(x_low - q))
      if (x_low &gt; q[q_ind_low]) {
        q_ind_low &lt;- q_ind_low + 1
      }
      x_lc[k, 1:q_ind_low] &lt;- x_low
      
      # Value functions of HH 2 under the relative Pareto weights x
      # (I use interpolation since x_low might not be on the grid q)
      V2_x &lt;- apply(V2, 1, function(y) approxfun(q, y, rule = 2)(x_low))
      
      # Calculate consumption of HH 1 at a relative Pareto weight x_low
      f &lt;- function(w) util_prime(inc_ag[k] - w, sigma2) / util_prime(w, sigma1) - x_low
      cons_x_low &lt;- uniroot(f, c(1e-6, (inc_ag[k] - 1e-6)), tol = 1e-8, maxiter = 100)$root
      cons1_lc[k, 1:q_ind_low] &lt;- cons_x_low
      V1_new[k, 1:q_ind_low] &lt;- Uaut[k, 1]
      V2_new[k, 1:q_ind_low] &lt;- util((inc_ag[k] - cons_x_low), sigma2) + delta * R[k,] %*% V2_x
    } else if (calc_diff_val_aut_1(qmax) &lt; 0) {
      V1_new[k,] &lt;- Uaut[k, 1]
      V2_new[k,] &lt;- Uaut[k, 2]
      x_lc[k,] &lt;- qmax
      q_ind_low &lt;- g + 2
    } else if (calc_diff_val_aut_1(qmin) &gt; 0) {
      q_ind_low &lt;- 0
    }
  
    # If the relative Pareto weight is too high and violates the PC, then
    # set the relative Pareto weight to the upper bound of the interval, and
    # HH2 gets the value under autarky.
    if ((calc_diff_val_aut_2(qmin) &gt; 0) &amp;&amp; calc_diff_val_aut_2(qmax) &lt; 0) {
      
      # Derive the relative Pareto weight that satisfies the equation (2)
      # in the supplementary material of Laczo (2015)
      x_high &lt;- uniroot(calc_diff_val_aut_2, c(qmin, qmax), tol = 1e-8, maxiter = 100)$root
      x_int[k, 2] &lt;- x_high
      
      # Index of the point on the grid of relative Pareto weights (q) closest to x_low
      q_ind_high &lt;- which.min(abs(x_high - q))
      if (x_high &gt; q[q_ind_high]) {
        q_ind_high &lt;- q_ind_high + 1
      }
      x_lc[k, 1:q_ind_high] &lt;- x_high
      
      # Value functions of HH 2 under the relative Pareto weights x
      # (I use interpolation since x_high might not be on the grid q)
      V1_x &lt;- apply(V1, 1, function(y) approxfun(q, y, rule = 2)(x_high))
      
      # Calculate consumption of HH 1 at a relative Pareto weight x_high
      f &lt;- function(w) util_prime(inc_ag[k] - w, sigma2) / util_prime(w, sigma1) - x_high
      cons_x_high &lt;- uniroot(f, c(1e-6, (inc_ag[k] - 1e-6)), tol = 1e-8, maxiter = 100)$root
      cons1_lc[k, q_ind_high:(g + 1)] &lt;- cons_x_high
      V1_new[k, q_ind_high:(g + 1)] &lt;- util(cons_x_high, sigma1) + delta * R[k,] %*% V1_x
      V2_new[k, q_ind_high:(g + 1)] &lt;- Uaut[k, 2]
    } else if (calc_diff_val_aut_2(qmin) &lt; 0) {
      V1_new[k,] &lt;- Uaut[k, 1]
      V2_new[k,] &lt;- Uaut[k, 2]
      x_lc[k,] &lt;- qmax
      q_ind_high &lt;- 0
    } else if (calc_diff_val_aut_1(qmax) &gt; 0) {
      q_ind_high &lt;- g + 2
    }
    
    if ((q_ind_low + 1) &lt; (q_ind_high - 1)) {
      V1_new[k, (q_ind_low + 1):(q_ind_high - 1)] &lt;- util(cons1[k, (q_ind_low + 1):(q_ind_high - 1)], sigma1) + delta * R[k,] %*% V1[, (q_ind_low + 1):(q_ind_high - 1)]
      V2_new[k, (q_ind_low + 1):(q_ind_high - 1)] &lt;- util(inc_ag[k] - cons1[k, (q_ind_low + 1):(q_ind_high - 1)], sigma2) + delta * R[k,] %*% V2[, (q_ind_low + 1):(q_ind_high - 1)]
    }
    
  }
  
  diff &lt;- max(max(abs(V1_new - V1)), max(abs(V2_new - V2)))
  V1 &lt;- V1_new
  V2 &lt;- V2_new
  iter &lt;- iter + 1
  
}

x_int</code></pre>
<pre><code>##           [,1]      [,2]
## [1,] 0.9676304 1.0356206
## [2,] 1.4853764 1.1027281
## [3,] 0.9068517 0.6733149
## [4,] 0.9676304 1.0356206</code></pre>
<pre class="r"><code># Matrix of relative Pareto weights with which participation constraints are satisfied
# with equality
# (dim 1: income state, dim 2: relative Pareto weight)
x &lt;- matrix(q, nrow = S, ncol = (g + 1), byrow = TRUE)</code></pre>
<div id="refs" class="references">
<div id="ref-Kocherlakota1996">
<p>Kocherlakota, N. R. 1996. “Implications of Efficient Risk Sharing without Commitment.” <em>The Review of Economic Studies</em> 63 (4): 595–609. <a href="https://doi.org/10.2307/2297795">https://doi.org/10.2307/2297795</a>.</p>
</div>
<div id="ref-Laczo2015">
<p>Laczó, Sarolta. 2015. “RISK SHARING WITH LIMITED COMMITMENT AND PREFERENCE HETEROGENEITY: STRUCTURAL ESTIMATION AND TESTING.” <em>Journal of the European Economic Association</em> 13 (2): 265–92. <a href="https://doi.org/10.1111/jeea.12115">https://doi.org/10.1111/jeea.12115</a>.</p>
</div>
<div id="ref-Ligon2002">
<p>Ligon, Ethan, Jonathan P. Thomas, and Tim Worrall. 2002. “Informal Insurance Arrangements with Limited Commitment: Theory and Evidence from Village Economies.” <em>Review of Economic Studies</em> 69 (1): 209–44. <a href="https://doi.org/10.1111/1467-937X.00204">https://doi.org/10.1111/1467-937X.00204</a>.</p>
</div>
<div id="ref-Marcet2019">
<p>Marcet, Albert, and Ramon Marimon. 2019. “Recursive Contracts.” <em>Econometrica</em> 87 (5): 1589–1631.</p>
</div>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
